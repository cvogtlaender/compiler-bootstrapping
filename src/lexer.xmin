struct Token {
  string kind;
  string lexeme;
  int pos;
};

struct LexResult {
  bool ok;
  Token token;
  int nextPos;
  string err;
};

struct TokenList {
  Token head;
  TokenList tail;
};

Token mkToken(string kind, string lex, int pos) =
  Token(kind, lex, pos);

LexResult ok(Token t, int nextPos) =
  LexResult(true, t, nextPos, "");

LexResult err(string msg, int pos) =
  LexResult(false, Token("", "", pos), pos, msg);

TokenList cons(Token h, TokenList t) =
  TokenList(h, t);

int codeAt(string s, int i) =
  if (i < 0) then -1
  else if (i >= strlen(s)) then -1
  else ord(charAt(s, i));

bool eq2(string s, int i, int a, int b) =
  if (i + 1 >= strlen(s)) then false
  else (codeAt(s, i) == a && codeAt(s, i + 1) == b);

bool isDigitAt(string s, int i) =
  let int c = codeAt(s, i) in (c >= 48 && c <= 57);

bool isAlphaAt(string s, int i) =
  let int c = codeAt(s, i) in
    (c >= 65 && c <= 90) ||
    (c >= 97 && c <= 122) ||
    c == 95;

bool isAlnumAt(string s, int i) =
  isAlphaAt(s, i) || isDigitAt(s, i);

bool isWSAt(string s, int i) =
  let int c = codeAt(s, i) in
    c == 32 || c == 9 || c == 10 || c == 13;

int skipLineComment(string s, int i) =
  if (i >= strlen(s)) then i
  else if (codeAt(s, i) == 10) then i
  else skipLineComment(s, i + 1);

int skipBlockComment(string s, int i) =
  if (i + 1 >= strlen(s)) then -1
  else if (eq2(s, i, 42, 47)) then i + 2
  else skipBlockComment(s, i + 1);

int skipTrivia(string s, int i) =
  if (i >= strlen(s)) then i
  else if (isWSAt(s, i)) then skipTrivia(s, i + 1)
  else if (eq2(s, i, 47, 47)) then
    skipTrivia(s, skipLineComment(s, i + 2))
  else if (eq2(s, i, 47, 42)) then
    let int j = skipBlockComment(s, i + 2) in
      if (j < 0) then -1 else skipTrivia(s, j)
  else i;

int scanIntLenFrom(string s, int i) =
  if (i >= strlen(s)) then 0
  else if (isDigitAt(s, i)) then 1 + scanIntLenFrom(s, i + 1)
  else 0;

int scanIdLenFrom(string s, int i) =
  if (i >= strlen(s)) then 0
  else if (isAlnumAt(s, i)) then 1 + scanIdLenFrom(s, i + 1)
  else 0;

int scanStringContentLen(string s, int i) =
  if (i >= strlen(s)) then -1
  else if (codeAt(s, i) == 34) then 0
  else
    let int rest = scanStringContentLen(s, i + 1) in
      if (rest < 0) then -1 else 1 + rest;

string keywordOrId(string t) =
  if (t == "let") then "LET"
  else if (t == "in") then "IN"
  else if (t == "if") then "IF"
  else if (t == "then") then "THEN"
  else if (t == "else") then "ELSE"
  else if (t == "struct") then "STRUCT"
  else if (t == "true") then "TRUE"
  else if (t == "false") then "FALSE"
  else if (t == "null") then "NULL"
  else if (t == "int") then "KW_INT"
  else if (t == "bool") then "KW_BOOL"
  else if (t == "string") then "KW_STRING"
  else "ID";

LexResult nextToken(string s, int pos0) =
  let int pos = skipTrivia(s, pos0) in
  if (pos < 0) then err("unterminated block comment", pos0)
  else if (pos >= strlen(s)) then ok(mkToken("EOF", "", pos), pos)
  else
    if (eq2(s, pos, 61, 61)) then ok(mkToken("EQEQ", "==", pos), pos + 2)
    else if (eq2(s, pos, 33, 61)) then ok(mkToken("NEQ", "!=", pos), pos + 2)
    else if (eq2(s, pos, 60, 61)) then ok(mkToken("LE", "<=", pos), pos + 2)
    else if (eq2(s, pos, 62, 61)) then ok(mkToken("GE", ">=", pos), pos + 2)
    else if (eq2(s, pos, 38, 38)) then ok(mkToken("ANDAND", "&&", pos), pos + 2)
    else if (eq2(s, pos, 124, 124)) then ok(mkToken("OROR", "||", pos), pos + 2)

    else
      let int c = codeAt(s, pos) in
      if (c == 40) then ok(mkToken("LPAREN", "(", pos), pos + 1)
      else if (c == 41) then ok(mkToken("RPAREN", ")", pos), pos + 1)
      else if (c == 123) then ok(mkToken("LBRACE", "{", pos), pos + 1)
      else if (c == 125) then ok(mkToken("RBRACE", "}", pos), pos + 1)
      else if (c == 44) then ok(mkToken("COMMA", ",", pos), pos + 1)
      else if (c == 59) then ok(mkToken("SEMI", ";", pos), pos + 1)
      else if (c == 46) then ok(mkToken("DOT", ".", pos), pos + 1)
      else if (c == 61) then ok(mkToken("EQUAL", "=", pos), pos + 1)
      else if (c == 43) then ok(mkToken("PLUS", "+", pos), pos + 1)
      else if (c == 45) then ok(mkToken("MINUS", "-", pos), pos + 1)
      else if (c == 42) then ok(mkToken("STAR", "*", pos), pos + 1)
      else if (c == 47) then ok(mkToken("SLASH", "/", pos), pos + 1)
      else if (c == 37) then ok(mkToken("PERCENT", "%", pos), pos + 1)
      else if (c == 33) then ok(mkToken("BANG", "!", pos), pos + 1)
      else if (c == 60) then ok(mkToken("LT", "<", pos), pos + 1)
      else if (c == 62) then ok(mkToken("GT", ">", pos), pos + 1)

      else if (isDigitAt(s, pos)) then
        let int n = scanIntLenFrom(s, pos) in
          ok(mkToken("INT", substr(s, pos, n), pos), pos + n)

      else if (isAlphaAt(s, pos)) then
        let int n = scanIdLenFrom(s, pos + 1) in
        let int total = 1 + n in
        let string lex = substr(s, pos, total) in
          ok(mkToken(keywordOrId(lex), lex, pos), pos + total)

      else if (c == 34) then
        let int n = scanStringContentLen(s, pos + 1) in
          if (n < 0) then err("unterminated string", pos)
          else
            ok(mkToken("STRING", substr(s, pos + 1, n), pos), pos + 2 + n)

      else
        err("unexpected character", pos);

TokenList revGo(TokenList src, TokenList acc) =
  if (src == null) then acc
  else revGo(src.tail, cons(src.head, acc));

TokenList reverse(TokenList xs) =
  revGo(xs, null);

TokenList lexAllFrom(string s, int pos, TokenList accRev) =
  let LexResult r = nextToken(s, pos) in
    if (!r.ok) then null
    else


TokenList lex(string s) =
  lexAllFrom(s, 0, null);

int main() = {
  0;
};
